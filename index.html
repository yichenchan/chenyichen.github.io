<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="a student of HITsz————坚持滑板，热爱摇滚，偶尔弹吉他，喜欢阅读，抽空打游戏，在AI小白之路上踽踽独行。"><meta name="keywords" content=""><meta name="author" content="陈艺琛,undefined"><meta name="copyright" content="陈艺琛"><title>chenyichen's blog | 在AI小白之路上踽踽独行 | 艺琛的 Livehouse</title><link rel="shortcut icon" href="/img/logo1.png"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?20c8efd323cd63b9f6bf846113eb6f60";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avater.jpg"></div><div class="author-info__name text-center">陈艺琛</div><div class="author-info__description text-center">a student of HITsz————坚持滑板，热爱摇滚，偶尔弹吉他，喜欢阅读，抽空打游戏，在AI小白之路上踽踽独行。</div><div class="follow-button"><a href="https://web.okjike.com/user/9e0ec001-4bb6-4cab-af94-ea8b2f6067ef/post" target="_blank">在即刻上关注我</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">33</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" href="https://www.liaoxuefeng.com" target="_blank">廖雪峰的博客</a><a class="author-info-links__name text-center" href="https://mooc.study.163.com/smartSpec/detail/1001319001.htm" target="_blank">网易机器学习公开课</a><a class="author-info-links__name text-center" href="https://developers.google.com/machine-learning/crash-course/?hl=zh-cn" target="_blank">谷歌机器学习速成</a><a class="author-info-links__name text-center" href="http://www.hitsz.edu.cn/index.html" target="_blank">哈工大深圳主页</a></div></div></div><nav id="nav" style="background-image: url(https://raw.githubusercontent.com/yichenchan/blogimg/master/img/skater11.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">艺琛的 Livehouse</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/categories/学习笔记">学习笔记</a><a class="site-page" href="/categories/读书观影笔记">读书观影笔记</a><a class="site-page" href="/categories/个人随想">个人随想</a><a class="site-page" href="/categories/爱好和生活">爱好和生活</a><a class="site-page" href="/gallery">相册</a><a class="site-page" href="/archives">所有博客</a><a class="site-page" href="/tags">特色标签</a><a class="site-page" href="/about">关于我</a></span></div><div id="site-info"><div id="site-title">艺琛的 Livehouse</div><div id="site-sub-title">chenyichen's blog | 在AI小白之路上踽踽独行</div><div id="site-social-icons"><a class="social-icon" href="https://github.com/yichenchan" target="_blank"><i class="fa fa-github"></i></a><a class="social-icon" href="https://weibo.com/5101047894/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" target="_blank"><i class="fa fa-weibo"></i></a><a class="social-icon" href="c840098794@gmail.com" target="_blank"><i class="fa fa-email"></i></a><a class="social-icon" href="https://steamcommunity.com/id/840098794/" target="_blank"><i class="fa fa-steam"></i></a><a class="social-icon search"><i class="fa fa-search"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/22/吴恩达机器学习c5w2编程作业/">coursera 吴恩达深度学习 Specialization 编程作业（course 5 week 2）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/学习笔记/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/吴恩达深度学习笔记/">吴恩达深度学习笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/词向量/">词向量</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Debiasing-word-vectors/">Debiasing word vectors</a></span><div class="content"><h1 id="Part1-Operations-on-word-vectors"><a href="#Part1-Operations-on-word-vectors" class="headerlink" title="Part1 - Operations on word vectors"></a>Part1 - Operations on word vectors</h1><p>通过这部分我们将学会：</p>
<ul>
<li>加载预训练词向量，用 cos 相似度测量相似度</li>
<li>使用词嵌入解决词语类比问题</li>
<li>减少词向量中的性别偏差</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> w2v_utils <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></div><a class="more" href="/2018/12/22/吴恩达机器学习c5w2编程作业/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/17/吴恩达机器学习笔记c5w2/">coursera 吴恩达深度学习 Specialization 笔记（course 5 week 1）—— 循环神经网络 RNN</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/学习笔记/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/吴恩达深度学习笔记/">吴恩达深度学习笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Word-Embedding/">Word Embedding</a></span><div class="content"><p>自然语言处理和深度学习是非常重要的组合。使用词向量表示和嵌入层可以在许多行业训练 RNN，例如情感分析，命名实体识别和机器翻译。</p>
<h2 id="Word-Embeddings-词嵌入介绍"><a href="#Word-Embeddings-词嵌入介绍" class="headerlink" title="Word Embeddings 词嵌入介绍"></a>Word Embeddings 词嵌入介绍</h2><h3 id="Word-representation"><a href="#Word-representation" class="headerlink" title="Word representation"></a>Word representation</h3><p>如何用向量表示一个词？假设我们有一个词汇表 V，数量为 |V| = 10000，V = {a, aaron,…, zulu,\<unk>}，我们可以用 one-hot 编码来表示这些词：</unk></p>
<p><img src="https://raw.githubusercontent.com/yichenchan/blogimg/master/img/dl_5.2_1.png" alt=""></p></div><a class="more" href="/2018/12/17/吴恩达机器学习笔记c5w2/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/13/用 numpy 进行快速傅立叶变换 fft/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-13</time><div class="content"><p>date: 2018/12/13</p>
<p>工程信号处理作业，用 matlab 对一个信号进行傅立叶变换，由于从没用过 matlab，所以想看看 python 能不能做，一查果然 numpy 有 fft 的函数。</p>
<p>fft 就是把信号在时域的采样的 N 个实数，变成时域的 N 个复数，具体的输入输出见这个<a href="https://www.youtube.com/watch?v=z7X6jgFnB6Y" target="_blank" rel="noopener">youtube 视频</a>.</p>
<p><img src="https://raw.githubusercontent.com/yichenchan/blogimg/master/img/2018/12/13_1.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">N = <span class="number">1000</span>    <span class="comment">#采样点数</span></span><br><span class="line">Td = <span class="number">4</span>      <span class="comment">#采样总时间,采样总时间的倒数就是频谱的分辨率 df</span></span><br><span class="line">fs = N/Td   <span class="comment">#采样频率</span></span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>,Td,N)	<span class="comment">#采样时域的坐标</span></span><br><span class="line">y = np.sin(<span class="number">100</span>*(x<span class="number">-2</span>))/(<span class="number">50</span>*(x<span class="number">-2</span>))	<span class="comment">#需要进行傅立叶变换的函数</span></span><br><span class="line"></span><br><span class="line">freqx = np.fft.fftfreq(N,d=<span class="number">1</span>/fs)	<span class="comment">#频域的坐标,采样 N 个点那么频域也有 N 个点,fftfreq 直接生成 N 个频域点的*实际*坐标</span></span><br><span class="line"><span class="comment">#fftfreqs 第二个参数 d 是采样频率的倒数，那么频谱分辨率 df=1/Td=1/(N/fs)=fs/N=1/(d*N)=1/Td</span></span><br><span class="line"></span><br><span class="line">fft_vals = np.fft.fft(y)	<span class="comment">#未经处理的 fft 输出,幅度只有实际值的一半,而且未经过归一化</span></span><br><span class="line">fft_theo = <span class="number">2.0</span>*np.abs(fft_vals/N)	<span class="comment">#根据公式,除以 N 归一化之后 abs 求幅度,再将幅度乘以 2 就是真实的幅度值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">'oringin signal'</span>)</span><br><span class="line">plt.plot(x,y,color=<span class="string">'red'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'time(s)'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">'true fft output in frequency domain'</span>)</span><br><span class="line">plt.plot(freqx, fft_theo)</span><br><span class="line">plt.xlabel(<span class="string">'frequency(Hz)'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/yichenchan/blogimg/master/img/2018/12/13/2.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/yichenchan/blogimg/master/img/2018/12/13/3.png" alt=""></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/03/25days_challenge/">无题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-03</time><div class="content"><h2 id="day1-——-判断-list-中最先出现两次的元素"><a href="#day1-——-判断-list-中最先出现两次的元素" class="headerlink" title="day1 ——  判断 list 中最先出现两次的元素"></a>day1 ——  判断 list 中最先出现两次的元素</h2><blockquote>
<p>—- Day 1: Chronal Calibration —-<br>“We’ve detected some temporal anomalies,”one of Santa’s Elves at the Temporal Anomaly Research and Detection Instrument Station tells you. She sounded pretty worried when she called you down here. “At 500-year intervals into the past, someone has been changing Santa’s history!”</p>
<p>“The good news is that the changes won’t propagate to our time stream for another 25 days, and we have a device”- she attaches something to your wrist -“that will let you fix the changes with no such propagation delay. It’s configured to send you 500 years further into the past every few days; that was the best we could do on such short notice.”</p>
<p>“The bad news is that we are detecting roughly fifty anomalies throughout time; the device will indicate fixed anomalies with stars. The other bad news is that we only have one device and you’re the best person for the job! Good lu—“ She taps a button on the device and you suddenly feel like you’re falling. To save Christmas, you need to get all fifty stars by December 25th.</p>
<p>Collect stars by solving puzzles. Two puzzles will be made available on each day in the advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!</p>
<p>After feeling like you’ve been falling for a few minutes, you look at the device’s tiny screen. “Error: Device must be calibrated before first use. Frequency drift detected. Cannot maintain destination lock.” Below the message, the device shows a sequence of changes in frequency (your puzzle input). A value like +6 means the current frequency increases by 6; a value like -3 means the current frequency decreases by 3.</p>
<p>For example, if the device displays frequency changes of +1, -2, +3, +1, then starting from a frequency of zero, the following changes would occur:</p>
<p>Current frequency  0, change of +1; resulting frequency  1.<br>Current frequency  1, change of -2; resulting frequency -1.<br>Current frequency -1, change of +3; resulting frequency  2.<br>Current frequency  2, change of +1; resulting frequency  3.<br>In this example, the resulting frequency is 3.</p>
<p>Here are other example situations:</p>
<p>+1, +1, +1 results in  3<br>+1, +1, -2 results in  0<br>-1, -2, -3 results in -6<br>Starting with a frequency of zero, what is the resulting frequency after all of the changes in frequency have been applied?</p>
<p>If you still want to see it, you can <a href="https://adventofcode.com/2018/day/1/input" target="_blank" rel="noopener">get your puzzle input</a>.</p>
<p>Your puzzle answer was 466.</p>
<p>—- Part Two —-<br>You notice that the device repeats the same frequency change list over and over. To calibrate the device, you need to find the first frequency it reaches twice.</p>
<p>For example, using the same list of changes above, the device would loop as follows:</p>
<p>Current frequency  0, change of +1; resulting frequency  1.<br>Current frequency  1, change of -2; resulting frequency -1.<br>Current frequency -1, change of +3; resulting frequency  2.<br>Current frequency  2, change of +1; resulting frequency  3.<br>(At this point, the device continues from the start of the list.)<br>Current frequency  3, change of +1; resulting frequency  4.<br>Current frequency  4, change of -2; resulting frequency  2, which has already been seen.<br>In this example, the first frequency reached twice is 2. Note that your device might need to repeat its list of frequency changes many times before a duplicate frequency is found, and that duplicates might be found while in the middle of processing the list.</p>
<p>Here are other examples:</p>
<p>+1, -1 first reaches 0 twice.<br>+3, +3, +4, -2, -4 first reaches 10 twice.<br>-6, +3, +8, +5, -6 first reaches 5 twice.<br>+7, +7, -2, -7, -4 first reaches 14 twice.<br>What is the first frequency your device reaches twice?</p>
<p>Your puzzle answer was 750.</p>
<p>Both parts of this puzzle are complete! They provide two gold stars: **</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'day1.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">numbers_str = f.read()	<span class="comment"># 读取 str 形式的数字</span></span><br><span class="line">numbers_str = numbers_str.split() 	<span class="comment"># 分隔这个字符串 </span></span><br><span class="line">numbers_int = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> numbers_str:	<span class="comment"># 将 list 中每个元素的 str 变成 int</span></span><br><span class="line">    <span class="keyword">if</span> i[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">        numbers_of_i = int(i[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        numbers_of_i = -int(i[<span class="number">1</span>:])</span><br><span class="line">    numbers_int.append(numbers_of_i)</span><br><span class="line">print(sum(numbers_int)) <span class="comment"># 将所有频率变化求和得到最后频率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</span><br><span class="line">freq = set([<span class="number">0</span>]) <span class="comment"># 使用 set() 当作容器进行查找速度最快</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cycle(numbers_int): <span class="comment"># cycle() 进行循环迭代</span></span><br><span class="line">    sum += i <span class="comment"># sum 是目前的频率</span></span><br><span class="line">    <span class="keyword">if</span> sum <span class="keyword">in</span> freq:	<span class="comment"># 判断 sum 是否在之前的 set 中出现过</span></span><br><span class="line">        print(<span class="string">'find it!--&gt;'</span>,sum)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i +=<span class="number">1</span></span><br><span class="line">        freq.add(sum)	<span class="comment"># 给 set 添加元素是 .add()</span></span><br><span class="line">        print(<span class="string">'|'</span>)</span><br></pre></td></tr></table></figure>
<p>收获：</p>
<ul>
<li><code>list.split()</code>通过指定分隔符对字符串进行切片</li>
<li>当使用 <code>if sum in freq</code> 判断 sum 是否在 freq 中出现过时，如果 freq 是一个 list，查找速度非常非常慢，我花了十几分钟都没有得出结果，而使用 set() 进行查找时，不到一秒钟得到结果，查找速度的差异可见一斑</li>
<li>如果要对一个 list 进行循环迭代，可以不用 if 语句，而是使用 cycle() 构建一个无限循环的可迭代对象</li>
</ul>
<h2 id="day2-——-判断字符串中各个字符出现次数"><a href="#day2-——-判断字符串中各个字符出现次数" class="headerlink" title="day2 —— 判断字符串中各个字符出现次数"></a>day2 —— 判断字符串中各个字符出现次数</h2><blockquote>
<h2 id="—-Day-2-Inventory-Management-System-—"><a href="#—-Day-2-Inventory-Management-System-—" class="headerlink" title="—- Day 2: Inventory Management System —-"></a>—- Day 2: Inventory Management System —-</h2><p>You stop falling through time, catch your breath, and check the screen on the device. “Destination reached. Current Year: 1518. Current Location: North Pole Utility Closet 83N10.” You made it! Now, to find those anomalies.</p>
<p>Outside the utility closet, you hear footsteps and a voice. “…I’m not sure either. But now that so many people have chimneys, maybe he could sneak in that way?”Another voice responds,”Actually, we’ve been working on a new kind of <em>suit</em> that would let him fit through tight spaces like that. But, I heard that a few days ago, they lost the prototype fabric, the design plans, everything! Nobody on the team can even seem to remember important details of the project!”</p>
<p>“Wouldn’t they have had enough fabric to fill several boxes in the warehouse? They’d be stored together, so the box IDs should be similar. Too bad it would take forever to search the warehouse for <em>two similar box IDs</em>…” They walk too far away to hear any more.</p>
<p>Late at night, you sneak to the warehouse - who knows what kinds of paradoxes you could cause if you were discovered - and use your fancy wrist device to quickly scan every box and produce a list of the likely candidates (your puzzle input).</p>
<p>To make sure you didn’t miss any, you scan the likely candidate boxes again, counting the number that have an ID containing <em>exactly two of any letter</em> and then separately counting those with <em>exactly three of any letter</em>. You can multiply those two counts together to get a rudimentary <a href="https://en.wikipedia.org/wiki/Checksum" target="_blank" rel="noopener">checksum</a>and compare it to what your device predicts.</p>
<p>For example, if you see the following box IDs:</p>
<ul>
<li><code>abcdef</code> contains no letters that appear exactly two or three times.</li>
<li><code>bababc</code> contains two <code>a</code> and three <code>b</code>, so it counts for both.</li>
<li><code>abbcde</code> contains two <code>b</code>, but no letter appears exactly three times.</li>
<li><code>abcccd</code> contains three <code>c</code>, but no letter appears exactly two times.</li>
<li><code>aabcdd</code> contains two <code>a</code> and two <code>d</code>, but it only counts once.</li>
<li><code>abcdee</code> contains two <code>e</code>.</li>
<li><code>ababab</code> contains three <code>a</code> and three <code>b</code>, but it only counts once.</li>
</ul>
<p>Of these box IDs, four of them contain a letter which appears exactly twice, and three of them contain a letter which appears exactly three times. Multiplying these together produces a checksum of <code>4 * 3 = 12</code>.</p>
<p><em>What is the checksum</em> for your list of box IDs?</p>
<p>Your puzzle answer was <code>4693</code>.</p>
<h2 id="—-Part-Two-—"><a href="#—-Part-Two-—" class="headerlink" title="—- Part Two —-"></a>—- Part Two —-</h2><p>Confident that your list of box IDs is complete, you’re ready to find the boxes full of prototype fabric.</p>
<p>The boxes will have IDs which differ by exactly one character at the same position in both strings. For example, given the following box IDs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; abcde</span><br><span class="line">&gt; fghij</span><br><span class="line">&gt; klmno</span><br><span class="line">&gt; pqrst</span><br><span class="line">&gt; fguij</span><br><span class="line">&gt; axcye</span><br><span class="line">&gt; wvxyz</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The IDs <code>abcde</code> and <code>axcye</code> are close, but they differ by two characters (the second and fourth). However, the IDs <code>fghij</code> and <code>fguij</code> differ by exactly one character, the third (<code>h</code> and <code>u</code>). Those must be the correct boxes.</p>
<p><em>What letters are common between the two correct box IDs?</em> (In the example above, this is found by removing the differing character from either ID, producing <code>fgij</code>.)</p>
<p>Your puzzle answer was <code>pebjqsalrdnckzfihvtxysomg</code>.</p>
<p>Both parts of this puzzle are complete! They provide two gold stars: **</p>
<p>At this point, you should <a href="https://adventofcode.com/2018" target="_blank" rel="noopener">return to your advent calendar</a> and try another puzzle.</p>
<p>If you still want to see it, you can <a href="https://adventofcode.com/2018/day/2/input" target="_blank" rel="noopener">get your puzzle input</a>.</p>
</blockquote>
<p>我的很菜的解决方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">data = open(<span class="string">'day2.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line">IDs = data.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Part 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">if2or3</span><span class="params">(i)</span>:</span> <span class="comment"># 定义一个函数用来判断是否有字符出现两次或者三次</span></span><br><span class="line">    count2 = <span class="number">0</span></span><br><span class="line">    count3 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">''</span>:	<span class="comment"># 很傻的办法：从字符串的第一个字符开始判断，判断完把所有的该字符删掉，直到删完为止...</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> i.count(i[<span class="number">0</span>]) == <span class="number">2</span>:</span><br><span class="line">                count2 = <span class="number">1</span></span><br><span class="line">                i = i.replace(i[<span class="number">0</span>], <span class="string">''</span>)  <span class="comment"># replace 不会改变 i 的内容啊啊啊啊啊啊</span></span><br><span class="line">            <span class="keyword">elif</span> i.count(i[<span class="number">0</span>]) == <span class="number">3</span>:</span><br><span class="line">                count3 = <span class="number">1</span></span><br><span class="line">                i = i.replace(i[<span class="number">0</span>], <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i = i.replace(i[<span class="number">0</span>], <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> count2,count3</span><br><span class="line"></span><br><span class="line">total2 = <span class="number">0</span></span><br><span class="line">total3 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ID <span class="keyword">in</span> IDs:	<span class="comment"># 遍历所有的 ID</span></span><br><span class="line">    count2, count3 = if2or3(ID)</span><br><span class="line">    total2 += count2</span><br><span class="line">    total3 += count3</span><br><span class="line">print(total2*total3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Part 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diff</span><span class="params">(a,b)</span>:</span> <span class="comment">#  用来判断 a 和 b 有几个不一样的字符</span></span><br><span class="line">    <span class="keyword">return</span> len(a) - sum([a[i]==b[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a))])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(IDs)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> IDs[i+<span class="number">1</span>:]: <span class="comment"># 每个 ID 都和其后的所有 ID 进行比较</span></span><br><span class="line">        <span class="keyword">if</span> diff(j,IDs[i]) == <span class="number">1</span>:</span><br><span class="line">            same_str = <span class="string">""</span>.join([j[index] <span class="keyword">for</span> index <span class="keyword">in</span> range(len(j)) <span class="keyword">if</span> j[index]==IDs[i][index] ]) <span class="comment"># 将相同的字符找出来并合成一个字符串</span></span><br><span class="line">            print(<span class="string">'we find it!--&gt;'</span>,same_str)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>reddit 网友 <a href="https://www.reddit.com/user/CFD999" target="_blank" rel="noopener">CFD999</a> 的超神版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Part 1: </span></span><br><span class="line">print((<span class="keyword">lambda</span> strs: (<span class="keyword">lambda</span> a,b: a*b)(*[sum(<span class="number">1</span> <span class="keyword">for</span> l <span class="keyword">in</span> strs <span class="keyword">if</span> any(l.count(c) == x <span class="keyword">for</span> c <span class="keyword">in</span> l)) <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>)]))(open(<span class="string">'inp'</span>, <span class="string">'r'</span>).readlines()))</span><br><span class="line"><span class="comment">#Part 2: </span></span><br><span class="line">print((<span class="keyword">lambda</span> strs: (<span class="keyword">lambda</span> a,b: <span class="string">""</span>.join([a[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)) <span class="keyword">if</span> a[i] == b[i]]))(*[(l1.strip(),l2.strip()) <span class="keyword">for</span> l1 <span class="keyword">in</span> strs <span class="keyword">for</span> l2 <span class="keyword">in</span> strs <span class="keyword">if</span> l1 != l2 <span class="keyword">and</span> sum(<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l1)<span class="number">-1</span>) <span class="keyword">if</span> l1[i] != l2[i]) &lt; <span class="number">2</span>][<span class="number">0</span>]))(open(<span class="string">'inp'</span>, <span class="string">'r'</span>).readlines()))</span><br></pre></td></tr></table></figure>
<p>还有另一个网友的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">myfile = open(<span class="string">'input.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">contents = myfile.read().strip().splitlines()</span><br><span class="line">myfile.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># part 1</span></span><br><span class="line">c = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> contents:</span><br><span class="line">    a = Counter(i).values()	<span class="comment"># counter 类用来跟踪值出现的次数，返回一个字典</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">3</span> <span class="keyword">in</span> a:</span><br><span class="line">        c[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span> <span class="keyword">in</span> a:</span><br><span class="line">        c[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">print(c[<span class="number">0</span>] * c[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># part 2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> contents:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> contents:</span><br><span class="line">            diffs = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> idx, ch <span class="keyword">in</span> enumerate(i): <span class="comment"># enumerate() 将将一个可遍历的数据对象 (如列表、元组或字符串) 组合为一个索引序列</span></span><br><span class="line">                <span class="keyword">if</span> ch != j[idx]:</span><br><span class="line">                    diffs += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> diffs == <span class="number">1</span>:</span><br><span class="line">                ans = [ch <span class="keyword">for</span> idx, ch <span class="keyword">in</span> enumerate(i) <span class="keyword">if</span> j[idx] == ch]</span><br><span class="line">                print(<span class="string">"Part Two:"</span>, <span class="string">''</span>.join(ans))</span><br></pre></td></tr></table></figure>
<p>收获：</p>
<ul>
<li>去掉字符串中某个字符可以用 <code>.replace(i, &#39;&#39;)</code> ，但是不会改变原来的值!!!!!</li>
<li>把 dict 变成 list 可以使用 <code>&#39;&#39;.join(list)</code>, 它的作用是将一个序列排列成一个字符串</li>
<li>counter 类用来跟踪值出现的次数，返回一个字典，比如 c = Counter(“aaabbb”) = {‘a’:3,’b’:3}</li>
<li>当需要一个序列的索引值时使用 enumerate() </li>
</ul>
<h2 id="day3-——-求多个矩形公共部分"><a href="#day3-——-求多个矩形公共部分" class="headerlink" title="day3 —— 求多个矩形公共部分"></a>day3 —— 求多个矩形公共部分</h2><blockquote>
<h2 id="—-Day-3-No-Matter-How-You-Slice-It-—"><a href="#—-Day-3-No-Matter-How-You-Slice-It-—" class="headerlink" title="—- Day 3: No Matter How You Slice It —-"></a>—- Day 3: No Matter How You Slice It —-</h2><p>The Elves managed to locate the chimney-squeeze prototype fabric for Santa’s suit (thanks to someone who helpfully wrote its box IDs on the wall of the warehouse in the middle of the night). Unfortunately, anomalies are still affecting them - nobody can even agree on how to <em>cut</em> the fabric.</p>
<p>The whole piece of fabric they’re working on is a very large square - at least <code>1000</code> inches on each side.</p>
<p>Each Elf has made a <em>claim</em> about which area of fabric would be ideal for Santa’s suit. All claims have an ID and consist of a single rectangle with edges parallel to the edges of the fabric. Each claim’s rectangle is defined as follows:</p>
<ul>
<li>The number of inches between the left edge of the fabric and the left edge of the rectangle.</li>
<li>The number of inches between the top edge of the fabric and the top edge of the rectangle.</li>
<li>The width of the rectangle in inches.</li>
<li>The height of the rectangle in inches.</li>
</ul>
<p>A claim like <code>#123 @ 3,2: 5x4</code> means that claim ID <code>123</code> specifies a rectangle <code>3</code> inches from the left edge, <code>2</code> inches from the top edge, <code>5</code> inches wide, and <code>4</code> inches tall. Visually, it claims the square inches of fabric represented by <code>#</code> (and ignores the square inches of fabric represented by <code>.</code>) in the diagram below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;...........</span><br><span class="line">&gt;...........</span><br><span class="line">&gt;...#####...</span><br><span class="line">&gt;...#####...</span><br><span class="line">&gt;...#####...</span><br><span class="line">&gt;...#####...</span><br><span class="line">&gt;...........</span><br><span class="line">&gt;...........</span><br><span class="line">&gt;...........</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The problem is that many of the claims <em>overlap</em>, causing two or more claims to cover part of the same areas. For example, consider the following claims:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;#1 @ 1,3: 4x4</span><br><span class="line">&gt;#2 @ 3,1: 4x4</span><br><span class="line">&gt;#3 @ 5,5: 2x2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Visually, these claim the following areas:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;........</span><br><span class="line">&gt;...2222.</span><br><span class="line">&gt;...2222.</span><br><span class="line">&gt;.11XX22.</span><br><span class="line">&gt;.11XX22.</span><br><span class="line">&gt;.111133.</span><br><span class="line">&gt;.111133.</span><br><span class="line">&gt;........</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The four square inches marked with <code>X</code> are claimed by <em>both 1 and 2</em>. (Claim <code>3</code>, while adjacent to the others, does not overlap either of them.)</p>
<p>If the Elves all proceed with their own plans, none of them will have enough fabric. <em>How many square inches of fabric are within two or more claims?</em></p>
<p>Your puzzle answer was <code>112378</code>.</p>
<h2 id="—-Part-Two-—-1"><a href="#—-Part-Two-—-1" class="headerlink" title="—- Part Two —-"></a>—- Part Two —-</h2><p>Amidst the chaos, you notice that exactly one claim doesn’t overlap by even a single square inch of fabric with any other claim. If you can somehow draw attention to it, maybe the Elves will be able to make Santa’s suit after all!</p>
<p>For example, in the claims above, only claim <code>3</code> is intact after all claims are made.</p>
<p><em>What is the ID of the only claim that doesn’t overlap?</em></p>
<p>Your puzzle answer was <code>603</code>.</p>
<p>Both parts of this puzzle are complete! They provide two gold stars: **</p>
<p>At this point, you should <a href="https://adventofcode.com/2018" target="_blank" rel="noopener">return to your advent calendar</a> and try another puzzle.</p>
<p>If you still want to see it, you can <a href="https://adventofcode.com/2018/day/3/input" target="_blank" rel="noopener">get your puzzle input</a>.</p>
</blockquote>
<p>我的答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">data = open(<span class="string">'day3.txt'</span>,<span class="string">'r'</span>).readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">claims = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    size = re.match(<span class="string">r'\D+(\d+)\D+(\d+)\D+(\d+)\D+(\d+)\D+(\d+)'</span>, i).groups()<span class="comment"># 正则表达式划分字符串</span></span><br><span class="line">    size = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> size][<span class="number">1</span>:]</span><br><span class="line">    claims.append(size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># part 1</span></span><br><span class="line">I_total = set()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> claims:	<span class="comment"># 这个循环找出所有矩形的交集矩形</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> claims:</span><br><span class="line">        <span class="keyword">if</span> j == i: <span class="keyword">continue</span></span><br><span class="line">        Iw = min(i[<span class="number">0</span>]+i[<span class="number">2</span>],j[<span class="number">0</span>]+j[<span class="number">2</span>])  - max(i[<span class="number">0</span>],j[<span class="number">0</span>])</span><br><span class="line">        Ih = min(i[<span class="number">1</span>]+i[<span class="number">3</span>],j[<span class="number">1</span>]+j[<span class="number">3</span>])  - max(i[<span class="number">1</span>],j[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> Iw&lt;=<span class="number">0</span> <span class="keyword">or</span> Ih&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            size_I = (max(i[<span class="number">0</span>],j[<span class="number">0</span>]),max(i[<span class="number">1</span>],j[<span class="number">1</span>]),Iw,Ih)</span><br><span class="line">            I_total.add(size_I)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_points_set</span><span class="params">(i)</span>:</span> <span class="comment"># 将一个矩形的点的坐标全部取出放到一个集合 set() 里</span></span><br><span class="line">    points = set([(k, l) <span class="keyword">for</span> k <span class="keyword">in</span> range(i[<span class="number">0</span>], i[<span class="number">0</span>] + i[<span class="number">2</span>]) <span class="keyword">for</span> l <span class="keyword">in</span> range(i[<span class="number">1</span>], i[<span class="number">1</span>] + i[<span class="number">3</span>])])</span><br><span class="line">    <span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line">points_set_list_I = list(map(find_points_set,I_total))	<span class="comment"># 将所有交集矩形的点坐标取出</span></span><br><span class="line">points_set_I = set([j <span class="keyword">for</span> i <span class="keyword">in</span> points_set_list_I <span class="keyword">for</span> j <span class="keyword">in</span> i]) 	<span class="comment"># 将所有的点放入一个set以去除重复的点</span></span><br><span class="line">print(len(points_set_I))	<span class="comment"># 这个点集的个数就是重叠的布料数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># part 2</span></span><br><span class="line">points_set_claim = list(map(find_points_set,claims))</span><br><span class="line">id = [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points_set_claim)) <span class="keyword">if</span> points_set_claim[i]&amp;points_set_I == set()]<span class="comment">#找出与交集矩形无交集的claim</span></span><br><span class="line">print(id)</span><br></pre></td></tr></table></figure>
<p>一个使用  numpy 的很巧妙的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'day3.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    inp = []</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> f.readlines():</span><br><span class="line">        r = re.split(<span class="string">'[^0-9]+'</span>, r[<span class="number">1</span>:].strip())<span class="comment">#[^0-9] 表示任何不是数字的字符</span></span><br><span class="line">        inp.append([int(d) <span class="keyword">for</span> d <span class="keyword">in</span> r])</span><br><span class="line"></span><br><span class="line">fabric = np.zeros((<span class="number">1000</span>, <span class="number">1000</span>)) <span class="comment"># 先将矩阵所有位标零，如果上面有claim，则把覆盖到的地方加1，最后结果&gt;2说明有两块以上claim在此重叠</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">part1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n, x, y, dx, dy <span class="keyword">in</span> inp:</span><br><span class="line">        fabric[x:x+dx, y:y+dy] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(fabric &gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">part2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n, x, y, dx, dy <span class="keyword">in</span> inp:</span><br><span class="line">        <span class="keyword">if</span> np.all(fabric[x:x+dx, y:y+dy] == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">print(part1())</span><br><span class="line">print(part2())</span><br></pre></td></tr></table></figure>
<p>另外一个很干净的答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">claims = [[*map(int, re.findall(<span class="string">r'\d+'</span>, l))] <span class="keyword">for</span> l <span class="keyword">in</span> input.splitlines() <span class="keyword">if</span> l]</span><br><span class="line">squares = <span class="keyword">lambda</span> c: ((i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(c[<span class="number">1</span>], c[<span class="number">1</span>]+c[<span class="number">3</span>])</span><br><span class="line">                            <span class="keyword">for</span> j <span class="keyword">in</span> range(c[<span class="number">2</span>], c[<span class="number">2</span>]+c[<span class="number">4</span>]))</span><br><span class="line">fabric = Counter(s <span class="keyword">for</span> c <span class="keyword">in</span> claims <span class="keyword">for</span> s <span class="keyword">in</span> squares(c))</span><br><span class="line"></span><br><span class="line">part1 = sum(<span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> fabric.values() <span class="keyword">if</span> v &gt; <span class="number">1</span>)</span><br><span class="line">part2 = next(c[<span class="number">0</span>] <span class="keyword">for</span> c <span class="keyword">in</span> claims <span class="keyword">if</span> all(fabric[s] == <span class="number">1</span> <span class="keyword">for</span> s <span class="keyword">in</span> squares(c)))</span><br></pre></td></tr></table></figure>
<p>收获：</p>
<ul>
<li><code>re.split(&#39;[^0-9]+&#39;, r.strip())</code> 用来找出一个字符串中所有的数字，<code>[^0-9]</code>表示除了数字以外的任何字符，也可以 <code>re.split(&#39;\D+&#39;, r.strip())</code>，r.strip() 用来去掉 split 后首位的两个空格，也可以 <code>re.findall(r&#39;\d+&#39;, l)</code></li>
<li>找到两个 list1 和 list2 公共元素的最快方法，set(list1) &amp; set(list2)，找到两个单词公共字母：<code>set(list(a))&amp;set(list(b))</code> </li>
<li>少用 for 循环！！太慢了！！使用 map 可以加快遍历的速度！！</li>
<li>将一个 list 中的 str 都变为 int：<code>map(int, list)</code></li>
</ul>
<h2 id="day4-——-数据中时间字符串的处理"><a href="#day4-——-数据中时间字符串的处理" class="headerlink" title="day4 ——  数据中时间字符串的处理"></a>day4 ——  数据中时间字符串的处理</h2><blockquote>
<h2 id="—-Day-4-Repose-Record-—"><a href="#—-Day-4-Repose-Record-—" class="headerlink" title="—- Day 4: Repose Record —-"></a>—- Day 4: Repose Record —-</h2><p>You’ve sneaked into another supply closet - this time, it’s across from the prototype suit manufacturing lab. You need to sneak inside and fix the issues with the suit, but there’s a guard stationed outside the lab, so this is as close as you can safely get.</p>
<p>As you search the closet for anything that might help, you discover that you’re not the first person to want to sneak in. Covering the walls, someone has spent an hour starting every midnight for the past few months secretly observing this guard post! They’ve been writing down the ID of <em>the one guard on duty that night</em> - the Elves seem to have decided that one guard was enough for the overnight shift - as well as when they fall asleep or wake up while at their post (your puzzle input).</p>
<p>For example, consider the following records, which have already been organized into chronological order:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;[1518-11-01 00:00] Guard #10 begins shift</span><br><span class="line">&gt;[1518-11-01 00:05] falls asleep</span><br><span class="line">&gt;[1518-11-01 00:25] wakes up</span><br><span class="line">&gt;[1518-11-01 00:30] falls asleep</span><br><span class="line">&gt;[1518-11-01 00:55] wakes up</span><br><span class="line">&gt;[1518-11-01 23:58] Guard #99 begins shift</span><br><span class="line">&gt;[1518-11-02 00:40] falls asleep</span><br><span class="line">&gt;[1518-11-02 00:50] wakes up</span><br><span class="line">&gt;[1518-11-03 00:05] Guard #10 begins shift</span><br><span class="line">&gt;[1518-11-03 00:24] falls asleep</span><br><span class="line">&gt;[1518-11-03 00:29] wakes up</span><br><span class="line">&gt;[1518-11-04 00:02] Guard #99 begins shift</span><br><span class="line">&gt;[1518-11-04 00:36] falls asleep</span><br><span class="line">&gt;[1518-11-04 00:46] wakes up</span><br><span class="line">&gt;[1518-11-05 00:03] Guard #99 begins shift</span><br><span class="line">&gt;[1518-11-05 00:45] falls asleep</span><br><span class="line">&gt;[1518-11-05 00:55] wakes up</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Timestamps are written using <code>year-month-day hour:minute</code> format. The guard falling asleep or waking up is always the one whose shift most recently started. Because all asleep/awake times are during the midnight hour (<code>00:00</code>- <code>00:59</code>), only the minute portion (<code>00</code> - <code>59</code>) is relevant for those events.</p>
<p>Visually, these records show that the guards are asleep at these times:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;Date   ID   Minute</span><br><span class="line">&gt;            000000000011111111112222222222333333333344444444445555555555</span><br><span class="line">&gt;            012345678901234567890123456789012345678901234567890123456789</span><br><span class="line">&gt;11-01  #10  .....####################.....#########################.....</span><br><span class="line">&gt;11-02  #99  ........................................##########..........</span><br><span class="line">&gt;11-03  #10  ........................#####...............................</span><br><span class="line">&gt;11-04  #99  ....................................##########..............</span><br><span class="line">&gt;11-05  #99  .............................................##########.....</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The columns are Date, which shows the month-day portion of the relevant day; ID, which shows the guard on duty that day; and Minute, which shows the minutes during which the guard was asleep within the midnight hour. (The Minute column’s header shows the minute’s ten’s digit in the first row and the one’s digit in the second row.) Awake is shown as <code>.</code>, and asleep is shown as <code>#</code>.</p>
<p>Note that guards count as asleep on the minute they fall asleep, and they count as awake on the minute they wake up. For example, because Guard #10 wakes up at 00:25 on 1518-11-01, minute 25 is marked as awake.</p>
<p>If you can figure out the guard most likely to be asleep at a specific time, you might be able to trick that guard into working tonight so you can have the best chance of sneaking in. You have two strategies for choosing the best guard/minute combination.</p>
<p><em>Strategy 1:</em> Find the guard that has the most minutes asleep. What minute does that guard spend asleep the most?</p>
<p>In the example above, Guard #10 spent the most minutes asleep, a total of 50 minutes (20+25+5), while Guard #99 only slept for a total of 30 minutes (10+10+10). Guard #<em>10</em> was asleep most during minute <em>24</em> (on two days, whereas any other minute the guard was asleep was only seen on one day).</p>
<p>While this example listed the entries in chronological order, your entries are in the order you found them. You’ll need to organize them before they can be analyzed.</p>
<p><em>What is the ID of the guard you chose multiplied by the minute you chose?</em>(In the above example, the answer would be <code>10 * 24 = 240</code>.)</p>
<p>Your puzzle answer was <code>76357</code>.</p>
<h2 id="—-Part-Two-—-2"><a href="#—-Part-Two-—-2" class="headerlink" title="—- Part Two —-"></a>—- Part Two —-</h2><p><em>Strategy 2:</em> Of all guards, which guard is most frequently asleep on the same minute?</p>
<p>In the example above, Guard #<em>99</em> spent minute <em>45</em> asleep more than any other guard or minute - three times in total. (In all other cases, any guard spent any minute asleep at most twice.)</p>
<p><em>What is the ID of the guard you chose multiplied by the minute you chose?</em>(In the above example, the answer would be <code>99 * 45 = 4455</code>.)</p>
<p>Your puzzle answer was <code>41668</code>.</p>
<p>Both parts of this puzzle are complete! They provide two gold stars: **</p>
<p>At this point, you should <a href="https://adventofcode.com/2018" target="_blank" rel="noopener">return to your advent calendar</a> and try another puzzle.</p>
<p>If you still want to see it, you can <a href="https://adventofcode.com/2018/day/4/input" target="_blank" rel="noopener">get your puzzle input</a>.</p>
</blockquote>
<p>越来越难了…菜鸟搞了两天才搞定==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = open(<span class="string">'day4.txt'</span>,<span class="string">'r'</span>).readlines()</span><br><span class="line"><span class="comment"># 把所有被打乱的数据按照时间顺序排列好，使用函数 sort()，strptime 把字符串变成可加减的时间</span></span><br><span class="line">data_sorted = sorted(data, key = <span class="keyword">lambda</span> x: datetime.strptime(re.findall(<span class="string">r'\[(.*?)\]'</span>,x)[<span class="number">0</span>], <span class="string">'%Y-%m-%d %H:%M'</span>))</span><br><span class="line">data = <span class="string">''</span>.join(data_sorted) <span class="comment"># 将list所有元素合成一个str便于使用正则</span></span><br><span class="line">time = re.split(<span class="string">'\[.*?Guard'</span>,data)[<span class="number">1</span>:] <span class="comment"># 按照每天的guard记录进行正则分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># part 1</span></span><br><span class="line">time_dict = &#123;&#125;</span><br><span class="line">values = []</span><br><span class="line"><span class="comment"># 将每天的记录中的有用时间提取出来，放入key为守卫编号的字典里</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> time:</span><br><span class="line">    key = <span class="string">''</span>.join(re.findall(<span class="string">r'#(\d+?)\s'</span>,i))<span class="comment">#得到的是一个list，需要变成str</span></span><br><span class="line">    time_series = re.findall(<span class="string">r'\n\[(.*?)\]'</span>, i)</span><br><span class="line">    value = [(int(time_series[j][<span class="number">-2</span>:]),int(time_series[j+<span class="number">1</span>][<span class="number">-2</span>:])) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,len(time_series),<span class="number">2</span>)] <span class="comment">#转成(睡觉时间，醒来时间)格式的tuple</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> time_dict.keys():</span><br><span class="line">        time_dict[key] = value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time_dict[key] += value</span><br><span class="line"><span class="comment"># 得到所有守卫的睡觉长度字典</span></span><br><span class="line">time_len = dict(zip(time_dict.keys(),map(<span class="keyword">lambda</span> x:sum([i[<span class="number">1</span>]-i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> x]), time_dict.values())))</span><br><span class="line">most_sleep_id = max(time_len, key = time_len.get) <span class="comment"># 得到字典value最大值的key </span></span><br><span class="line"><span class="comment"># 使用np数组，在[i[0]:i[1]]范围内对睡觉次数进行累加</span></span><br><span class="line">minutes = np.zeros((<span class="number">60</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> time_dict[most_sleep_id]:</span><br><span class="line">    minutes[i[<span class="number">0</span>]:i[<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">most_sleep_minute = list(minutes).index(max(minutes))<span class="comment"># 注意minutes是np数组，要转成list()</span></span><br><span class="line">print(int(most_sleep_id)*most_sleep_minute)</span><br><span class="line"></span><br><span class="line"><span class="comment"># part2</span></span><br><span class="line">sleep_times = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> time_dict.items():</span><br><span class="line">    minutes = np.zeros((<span class="number">60</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> v:</span><br><span class="line">        minutes[i[<span class="number">0</span>]:i[<span class="number">1</span>]]+=<span class="number">1</span> <span class="comment">#与上同理</span></span><br><span class="line">    sleep_times[k] = list(minutes)</span><br><span class="line">sleep_most = max(sleep_times.items(), key = <span class="keyword">lambda</span> x:max(x[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>大神的简洁的答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">data = open(<span class="string">'day4.txt'</span>,<span class="string">'r'</span>).read()</span><br><span class="line">guards = defaultdict(Counter)<span class="comment"># guards[key] 如果key不存在，那么添加这个key，值为一个默认的计数器</span></span><br><span class="line"><span class="keyword">for</span> t, m <span class="keyword">in</span> [l.split(<span class="string">'] '</span>) <span class="keyword">for</span> l <span class="keyword">in</span> sorted(data.splitlines()) <span class="keyword">if</span> l]:<span class="comment"># sorted() 直接根据字符串中的时间进行了排序！！？</span></span><br><span class="line">    <span class="comment"># 用 ] 将字符串分成两部分，第一部分是 t，第二部分是 m</span></span><br><span class="line">    t = datetime.strptime(t, <span class="string">'[%Y-%m-%d %H:%M'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'#'</span> <span class="keyword">in</span> m:</span><br><span class="line">        g = int(m.split(<span class="string">'#'</span>)[<span class="number">1</span>].split()[<span class="number">0</span>])	<span class="comment"># guard 的编号</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'falls'</span> <span class="keyword">in</span> m:</span><br><span class="line">        start = t</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'wakes'</span> <span class="keyword">in</span> m:</span><br><span class="line">        minutes = int((t - start).total_seconds() // <span class="number">60</span>)</span><br><span class="line">        <span class="comment"># 首先 guards[g] g 是一个不存在的 key，默认 guards[g] = 一个空的Counter类 Counter(&#123;&#125;)</span></span><br><span class="line">        guards[g].update(Counter(start.minute+i <span class="keyword">for</span> i <span class="keyword">in</span> range(minutes)))<span class="comment"># guard 储存的是在睡觉时间的所有时间点</span></span><br><span class="line">		<span class="comment"># .update 是更新这个计数器，最后得到某个守卫在各个时间点睡觉的次数</span></span><br><span class="line">        </span><br><span class="line">_, id = max((sum(c.values()), id) <span class="keyword">for</span> id, c <span class="keyword">in</span> guards.items())<span class="comment"># max((),(),()) 默认以()第一个元素排序</span></span><br><span class="line">part1 = id * guards[id].most_common()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">print(part1)</span><br><span class="line"></span><br><span class="line">(_, minute), id = max((c.most_common()[<span class="number">0</span>][::<span class="number">-1</span>], id) <span class="keyword">for</span> id, c <span class="keyword">in</span> guards.items())<span class="comment"># most_common() 按照数量从大到小排列计数器</span></span><br><span class="line"><span class="comment"># [::-1] 是反向，因为max((('55':3),id),...)这种是取第一个值进行max，所以要把 3 和 '55' 互换，让 3 变成第一个值</span></span><br><span class="line">part2 = id * minute</span><br><span class="line">print(part2)</span><br></pre></td></tr></table></figure>
<p>收获：</p>
<ul>
<li><code>sorted()</code> 十分强大，可以直接对某些格式化的数据进行自动排序！</li>
<li><code>datetime.strptime(t, &#39;时间格式&#39;)</code> 将 t 变成一个可以进行时间加减的时间变量。</li>
<li>当字典中某个键不存在时，使用  <code>dict = defaultdict()</code> 对该键值进行初始化，<code>defaultdict(list)</code> 初始化为一个<code>[]</code>，<code>defaultdict(int)</code> 初始化为 0，<code>defaultdict(counter)</code> 初始化为一个空的计数器。</li>
<li><code>max()</code> 是以括号里每个元素的第一个值为 key 进行比较，例如 max(((1,2),(3,4)), (…),……) 是以 1 为比较的参数 </li>
</ul>
<h2 id="day-5-——-字符串的查找与删除"><a href="#day-5-——-字符串的查找与删除" class="headerlink" title="day 5 —— 字符串的查找与删除"></a>day 5 —— 字符串的查找与删除</h2><blockquote>
<h2 id="—-Day-5-Alchemical-Reduction-—"><a href="#—-Day-5-Alchemical-Reduction-—" class="headerlink" title="—- Day 5: Alchemical Reduction —-"></a>—- Day 5: Alchemical Reduction —-</h2><p>You’ve managed to sneak in to the prototype suit manufacturing lab. The Elves are making decent progress, but are still struggling with the suit’s size reduction capabilities.</p>
<p>While the very latest in 1518 alchemical technology might have solved their problem eventually, you can do better. You scan the chemical composition of the suit’s material and discover that it is formed by extremely long <a href="https://en.wikipedia.org/wiki/Polymer" target="_blank" rel="noopener">polymers</a> (one of which is available as your puzzle input).</p>
<p>The polymer is formed by smaller <em>units</em> which, when triggered, react with each other such that two adjacent units of the same type and opposite polarity are destroyed. Units’types are represented by letters; units’ polarity is represented by capitalization. For instance, <code>r</code> and <code>R</code> are units with the same type but opposite polarity, whereas <code>r</code> and <code>s</code> are entirely different types and do not react.</p>
<p>For example:</p>
<ul>
<li>In <code>aA</code>, <code>a</code> and <code>A</code> react, leaving nothing behind.</li>
<li>In <code>abBA</code>, <code>bB</code> destroys itself, leaving <code>aA</code>. As above, this then destroys itself, leaving nothing.</li>
<li>In <code>abAB</code>, no two adjacent units are of the same type, and so nothing happens.</li>
<li>In <code>aabAAB</code>, even though <code>aa</code> and <code>AA</code> are of the same type, their polarities match, and so nothing happens.</li>
</ul>
<p>Now, consider a larger example, <code>dabAcCaCBAcCcaDA</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;dabAcCaCBAcCcaDA  The first &apos;cC&apos; is removed.</span><br><span class="line">&gt;dabAaCBAcCcaDA    This creates &apos;Aa&apos;, which is removed.</span><br><span class="line">&gt;dabCBAcCcaDA      Either &apos;cC&apos; or &apos;Cc&apos; are removed (the result is the same).</span><br><span class="line">&gt;dabCBAcaDA        No further actions can be taken.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>After all possible reactions, the resulting polymer contains <em>10 units</em>.</p>
<p><em>How many units remain after fully reacting the polymer you scanned?</em> (Note: in this puzzle and others, the input is large; if you copy/paste your input, make sure you get the whole thing.)</p>
<p>Your puzzle answer was <code>11298</code>.</p>
<h2 id="—-Part-Two-—-3"><a href="#—-Part-Two-—-3" class="headerlink" title="—- Part Two —-"></a>—- Part Two —-</h2><p>Time to improve the polymer.</p>
<p>One of the unit types is causing problems; it’s preventing the polymer from collapsing as much as it should. Your goal is to figure out which unit type is causing the most problems, remove all instances of it (regardless of polarity), fully react the remaining polymer, and measure its length.</p>
<p>For example, again using the polymer <code>dabAcCaCBAcCcaDA</code> from above:</p>
<ul>
<li>Removing all <code>A</code>/<code>a</code> units produces <code>dbcCCBcCcD</code>. Fully reacting this polymer produces <code>dbCBcD</code>, which has length 6.</li>
<li>Removing all <code>B</code>/<code>b</code> units produces <code>daAcCaCAcCcaDA</code>. Fully reacting this polymer produces <code>daCAcaDA</code>, which has length 8.</li>
<li>Removing all <code>C</code>/<code>c</code> units produces <code>dabAaBAaDA</code>. Fully reacting this polymer produces <code>daDA</code>, which has length 4.</li>
<li>Removing all <code>D</code>/<code>d</code> units produces <code>abAcCaCBAcCcaA</code>. Fully reacting this polymer produces <code>abCBAc</code>, which has length 6.</li>
</ul>
<p>In this example, removing all <code>C</code>/<code>c</code> units was best, producing the answer <em>4</em>.</p>
<p><em>What is the length of the shortest polymer you can produce</em> by removing all units of exactly one type and fully reacting the result?</p>
<p>Your puzzle answer was <code>5148</code>.</p>
<p>Both parts of this puzzle are complete! They provide two gold stars: **</p>
<p>At this point, you should <a href="https://adventofcode.com/2018" target="_blank" rel="noopener">return to your advent calendar</a> and try another puzzle.</p>
<p>If you still want to see it, you can <a href="https://adventofcode.com/2018/day/5/input" target="_blank" rel="noopener">get your puzzle input</a>.</p>
</blockquote>
<p>目前为止最简单的一次…半个小时搞定==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">polymers = open(<span class="string">'day5.txt'</span>,<span class="string">'r'</span>).readline().strip()</span><br><span class="line"></span><br><span class="line">A_Z = [chr(ch) <span class="keyword">for</span> ch <span class="keyword">in</span> range(<span class="number">0x41</span>, <span class="number">0x5B</span>)] <span class="comment"># 存放 A 到 Z 的 list</span></span><br><span class="line">Aa_Zz = [ch + ch.lower() <span class="keyword">for</span> ch <span class="keyword">in</span> A_Z]	<span class="comment"># 存放 Aa 到 Zz 的 list</span></span><br><span class="line">AaaA_ZzzZ = Aa_Zz + [i[::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> Aa_Zz] <span class="comment"># 存放 Aa aA 到 Zz zZ 的 list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Part 1</span></span><br><span class="line"><span class="comment"># 字符串处理函数，输入原聚合物的字符串，输出配对消去之后的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">polymers_process</span><span class="params">(polymers)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> AaaA_ZzzZ <span class="keyword">if</span> i <span class="keyword">in</span> polymers] == []: <span class="comment"># 如果无法继续配对</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> AaaA_ZzzZ:</span><br><span class="line">                polymers = polymers.replace(ch, <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> polymers</span><br><span class="line">print(len(polymers_process(polymers)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Part 2</span></span><br><span class="line">shortest = min(map(<span class="keyword">lambda</span> i:len(polymers_process(polymers.replace(i,<span class="string">''</span>).replace(i.lower(),<span class="string">''</span>))), A_Z))</span><br><span class="line">print(shortest)</span><br></pre></td></tr></table></figure>
<p>下面是一个无比优雅高效的解决方式，来自 reddit 网友 <a href="https://www.reddit.com/user/andreyrmg" target="_blank" rel="noopener">andreyrmg</a> .</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collapse</span><span class="params">(s)</span>:</span></span><br><span class="line">    p = [<span class="string">'.'</span>]	<span class="comment"># 用来存放最后配对后的字符串</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> s:</span><br><span class="line">        v = p[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> v != u <span class="keyword">and</span> v.lower() == u.lower(): <span class="comment"># 如果和最后一个字符是大小写关系，那么把最后一个字符pop出来，绝妙！</span></span><br><span class="line">            p.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.append(u)</span><br><span class="line">    <span class="keyword">return</span> len(p) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">s = open(<span class="string">'day5.txt'</span>).read().strip()</span><br><span class="line">print(collapse(s))</span><br><span class="line">print(min(collapse(c <span class="keyword">for</span> c <span class="keyword">in</span> s <span class="keyword">if</span> c.lower() != x) <span class="keyword">for</span> x <span class="keyword">in</span> ascii_lowercase))</span><br></pre></td></tr></table></figure>
<p>收获：</p>
<ul>
<li>字符大写 <code>a.upper()</code> 字符小写 <code>A.lower()</code></li>
<li><code>string</code> 模块中的 <code>ascii_lowercase</code> 指小写字母字符串 <code>&#39;abcdefghijklmnopqrstuvwxyz&#39;</code>，<code>ascii_uppercase</code> 指 <code>&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/02/吴恩达机器学习c5w1编程作业/">coursera 吴恩达深度学习 Specialization 编程作业（course 5 week 1）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/学习笔记/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/吴恩达深度学习笔记/">吴恩达深度学习笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/rnn/">rnn</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/lstm/">lstm</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/梯度剪枝/">梯度剪枝</a></span><div class="content"><h1 id="part-1-Building-your-Recurrent-Neural-Network-Step-by-Step"><a href="#part-1-Building-your-Recurrent-Neural-Network-Step-by-Step" class="headerlink" title="part 1- Building your Recurrent Neural Network - Step by Step"></a>part 1- Building your Recurrent Neural Network - Step by Step</h1><p>这是这一周编程作业的第一部分，让我们从无到有构建了 RNN 和 LSTM 的前向和反向传播函数，但是作业中给的公式出现很多问题，下面都是更正后的公式，还有一些符号的提法比较模糊，下面也做了说明。</p>
<p>首先引入需要的包。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> rnn_utils <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><h3 id="单个-RNN-前向传播"><a href="#单个-RNN-前向传播" class="headerlink" title="单个 RNN 前向传播"></a>单个 RNN 前向传播</h3><p><img src="https://raw.githubusercontent.com/yichenchan/blogimg/master/img/dl_code_5.1_1.png" alt=""></p></div><a class="more" href="/2018/12/02/吴恩达机器学习c5w1编程作业/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/01/deeplearning.ai 第五课第一周编程作业第一部分 lstm 反向传播部分的公式更正及推导/">deeplearning.ai 第五课第一周编程作业第一部分 lstm 反向传播部分的公式更正及推导</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/学习笔记/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/吴恩达深度学习笔记/">吴恩达深度学习笔记</a></span><div class="content"><p>第五课第一周第一部分的编程作业直接构建了 rnn 和 lstm 的前向传播和方向传播函数，但是这次作业实在做得坎坷无比，还以为是自己的问题，上论坛一看，没想到大家都在抱怨这一次的作业各种出问题，公式给的莫名其妙，得到的结果老是对不上答案，在 lstm 的反向传播部分甚至连公式都给错了，这里做一个更正，并给出自己的手写推导。</p></div><a class="more" href="/2018/12/01/deeplearning.ai 第五课第一周编程作业第一部分 lstm 反向传播部分的公式更正及推导/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/08/吴恩达机器学习笔记c5w1/">coursera 吴恩达深度学习 Specialization 笔记（course 5 week 1）—— 循环神经网络 RNN</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/学习笔记/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/吴恩达深度学习笔记/">吴恩达深度学习笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/rnn/">rnn</a></span><div class="content"><p>​    在“序列化模型”这门课的第一周，我们会学习到循环神经网络，这种模型对时间数据表现得非常好，它有几个变种，包括 LSTM，GRU 和 双向 RNN。</p>
<h1 id="序列化模型"><a href="#序列化模型" class="headerlink" title="序列化模型"></a>序列化模型</h1><h2 id="序列化模型的例子"><a href="#序列化模型的例子" class="headerlink" title="序列化模型的例子"></a>序列化模型的例子</h2><p><img src="https://raw.githubusercontent.com/yichenchan/blogimg/master/img/dl_5.1_1.png" alt=""></p></div><a class="more" href="/2018/11/08/吴恩达机器学习笔记c5w1/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/06/吴恩达机器学习c4w4编程作业/">coursera 吴恩达深度学习 Specialization 编程作业（course 4 week 4）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/学习笔记/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/吴恩达深度学习笔记/">吴恩达深度学习笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/cnn/">cnn</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/人脸识别/">人脸识别</a></span><div class="content"><h2 id="神经风格转换"><a href="#神经风格转换" class="headerlink" title="神经风格转换"></a>神经风格转换</h2><p>先引入需要的包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> scipy.io</span><br><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> imshow</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> nst_utils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure></div><a class="more" href="/2018/11/06/吴恩达机器学习c4w4编程作业/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/01/吴恩达机器学习笔记c4w4/">coursera 吴恩达深度学习 Specialization 笔记（course 4 week 4）—— 人脸识别</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/学习笔记/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/吴恩达深度学习笔记/">吴恩达深度学习笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/cnn/">cnn</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/人脸识别/">人脸识别</a></span><div class="content"><p>这一周我们将学习到如何利用 CNN 进行图片风格转换和人脸识别。</p>
<h2 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h2><h3 id="什么是人脸识别或人脸校验"><a href="#什么是人脸识别或人脸校验" class="headerlink" title="什么是人脸识别或人脸校验"></a>什么是人脸识别或人脸校验</h3><ul>
<li>人脸校验<ul>
<li>输出图片，姓名或身份号</li>
<li>输出是否输入图片是对应的那个人</li>
<li>这是一个 1：1 问题</li>
</ul>
</li>
<li>人脸识别<ul>
<li>有 K 个人的数据库</li>
<li>输入图片</li>
<li>输出这个人的 ID 号，如果它是这 K 个人之一的话，如果不是，输出“未识别”</li>
<li>这是一个 1：K 问题</li>
</ul>
</li>
</ul></div><a class="more" href="/2018/11/01/吴恩达机器学习笔记c4w4/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/10/25/吴恩达机器学习c4w3编程作业/">coursera 吴恩达深度学习 Specialization 编程作业（course 4 week 3）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/学习笔记/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/吴恩达深度学习笔记/">吴恩达深度学习笔记</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/cnn/">cnn</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/YOLO-算法/">YOLO 算法</a></span><div class="content"><p>这次编程作业介绍了一个极其牛逼的算法——yolo 算法，用来检测马路上的车辆和路标等，这次作业主要介绍了 yolo 算法的数据后处理部分，即从输出挑选出正确预测方框的过程。</p></div><a class="more" href="/2018/10/25/吴恩达机器学习c4w3编程作业/#more">阅读更多</a><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By 陈艺琛</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">这里是我的一亩自耕田，记录自己的学习过程，生活随想和读书笔记，感谢您的参观！</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>